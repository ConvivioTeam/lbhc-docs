{ 
  "0": {
    "id": "0",
    "title": "API Gateway",
    "content": " microserviceThe  microservice provides the interface from the public internet into the Directory of Services system. Its main function is handle RESTful requests from outside the system, pass the request (and associated data, as appropriate) into the event stream, and then consume appropriate response(s) in the event stream and handle sending that back in the HTTP reponse.RepositoryCode for the DoS  microservice is in the https://github.com/LBHackney-IT/DoS-api-gateway repository.API Spec docView the spec at SwaggerHub (@todo – swaggerhub link).View the raw spec document at https://github.com/LBHackney-IT/DoS-api-gateway/blob/master/docs/api/api-gateway.openapi.yml",
    "url": "/microservices/apigateway",
    "relUrl": "/microservices/apigateway"
  },
  "1": {
    "id": "1",
    "title": "Data Store",
    "content": "Data store microserviceStores and retrieves the data of the directory of service.Contains data for:  Providers  Services  Eligibility  Cost options  Events, including attending info  Contacts  Venues  Taxonomy, including          category      function      type      deliverable type      tag      RepositoryCode for the DoS  microservice is in the https://github.com/LBHackney-IT/DoS-data-store-service repository.",
    "url": "/microservices/datastore",
    "relUrl": "/microservices/datastore"
  },
  "2": {
    "id": "2",
    "title": "Event Sourcing",
    "content": ": Consuming and Publishing EventsEach microservice will need to source events from the event stream.If an app is built with Laravel, as most of the microservices will be, then it will need to use a library to work with the Kafka-powered event stream. and Laravel QueuesLaravel has an effective system for managing queues so Lumen, based on Laravel, can use the queue API.Running the Queue Worker(excerpt from Laravel queue docs on running the queue worker)Laravel includes a queue worker that will process new jobs as they are pushed onto the queue. You may run the worker using the queue:work Artisan command. Note that once the  queue:work command has started, it will continue to run until it is manually stopped or you close your terminal:$ php artisan queue:workTo keep the queue:work process running permanently in the background, you should use a process monitor such as Supervisor to ensure that the queue worker does not stop running.PHP + Kafka LibrariesThis project looks like it could be a useful driver to add to a Laravel Lumen microservice:  Kafka Queue driver for Laravel: https://github.com/rapideinternet/laravel-queue-kafkaSupported versions of LaravelTested on: [5.4, 5.5, 5.6, 5.7]AlternativesSee also:  https://github.com/arquivei/laravel-kafka-queue-connector  https://github.com/Superbalist/php-pubsub-kafka",
    "url": "/microservices/eventstream/eventsourcing",
    "relUrl": "/microservices/eventstream/eventsourcing"
  },
  "3": {
    "id": "3",
    "title": "Event Stream",
    "content": " MicroserviceThe event stream is the heart of the microservice ecosystem.Built on Apache Kafka, the event stream allows each microservice to function independently of the next, simply waiting for an appropriate event in the event stream to trigger an action. Once it has completed its action, if appropriate, it may put an event back into the event stream to trigger a downstream or dependent microservice.This sequence allows microservices to function without causing dependency failures. I.e. a failure in one microservice should not be allowed cause the whole system to fail or to cause cascading errors.Each microservice will need to include an event sourcing sub-system to respond to relevant events in the event stream for the microservice.There are many code libraries available for interacting with Apache Kafka. Read the documentation on event sourcing for more.Microservices and ingFurther readingVideos  Guido Schmutz, Oracle Code 2018 — Building Event Driven MicroServices with Apache Kafka  Chris Richardson, DockerCon 2016 — Microservices + Events + Docker = A Perfect TrioBlogs  ThoughtWorks — Scaling Microservices with an   Capital One Tech — Event-Streaming: An Additional Architectural Style to Supplement API Design",
    "url": "/microservices/eventstream",
    "relUrl": "/microservices/eventstream"
  },
  "4": {
    "id": "4",
    "title": "Microservices",
    "content": "A list of the microservices in the system.",
    "url": "/microservices",
    "relUrl": "/microservices"
  },
  "5": {
    "id": "5",
    "title": "Scraper",
    "content": " MicroserviceThe scraper microservice pulls in data from external data sources. It is built with a plugin architecture, so that scapers or crawlers for a variety of external sources can be created.Once data has been scraped, it should be put into the system event stream to create or update entries in the data store.PluginsThe scraper microservice is built for adding plugins. plugins are built with an Object Oriented architecture, so that a scraper plugin is registered if it extends Plugin base class.There are thus two basic plugin sets. Each is an abstract base class, so that it can be extended for a particular source, for example, where a different authentication key or method is required for access.1. Web Page scrapersThese are scrapers that make an HTTP GET request for a web page and then parse the page content to find the specific element on the page, e.g. using a CSS selector.&amp;lt;?phpabstract class WebPage extends Plugin implements WebPageInterface{    ...}Each individual source scraper should then extends WebPage to be identifiable and able to function as a web page scraper.2. API scrapersThese are scrapers that make HTTP GET (and possibly POST requests) for API resource endpoints and retrieve JSON (or XML) data in response.abstract class ApiPlugin extends Plugin implements ApiInterface{    ...}Each individual source scraper should then extends Api to be identifiable and able to function as an API scraper.Event Sourcing@todoRepositoryCode for the DoS  microservice is in the https://github.com/LBHackney-IT/DoS-scraper-service repository.",
    "url": "/microservices/scraper",
    "relUrl": "/microservices/scraper"
  },
  "6": {
    "id": "6",
    "title": "System Design",
    "content": " and ArchitectureThe system is designed with a loosely-coupled event-driven microservice architecture. An event stream sits at the core of the architecture as the mode of communication between services. Each microservice includes event sourcing and event creation routines.The event stream microservice is built on Apache Kafka.Loosley-coupledBad, bad, not goodIn a close-coupled microservice system design, individual microservices can call APIs on each other, making the functioning of one microservice dependent on the functioning of one or many others. A problem with an upstream microservice can cause the current microservice to fail, allowing others downstream to fail also.BetterLoosely-coupling microservices removes that dependency.Instead, each microservice publishes events to a shared event store or event stream when it completes a task or its state changes. At the same time, the microservice subscribes to events in the event store, which may trigger it to perform actions.This means that each transaction may take the form of a saga, a sequence of local transactions. Each local transaction updates the performs an action or updates the state of an item (such as saving to a database) and publishes a message or event to trigger the next local transaction in the saga.  Failure can be handled with a series of compensating actions that undo any changes made by preceding local transactions.Command Query Responsibility Segregation (CQRS)This allows the two sets of actions to be segregated effectively into two parts: the command-side and the query-side.  Command actions: Create, update or delete (HTTP POST, PUT/PATCH, DELETE requests) actions, which emits events when data changes.  Query actions: handles queries by executing them against one or more views that are kept up to date by subscribing to the stream of events emitted when data changes.Design (v0.2)Design schematicsProcess designSystem design",
    "url": "/microservices/systemdesign",
    "relUrl": "/microservices/systemdesign"
  },
  "7": {
    "id": "7",
    "title": "",
    "content": "",
    "url": "",
    "relUrl": ""
  },
  "8": {
    "id": "8",
    "title": "",
    "content": "",
    "url": "",
    "relUrl": ""
  },
  "9": {
    "id": "9",
    "title": "CI/CD Pipeline",
    "content": "CI and CD is provided by Jenkins.Each job is configured using Jenkins Declarative Pipelines.Pipeline files should be contained within the services repo to allow developers to modify the build process if required.",
    "url": "/infrastructure/ci-cd-pipeline.html",
    "relUrl": "/infrastructure/ci-cd-pipeline.html"
  },
  "10": {
    "id": "10",
    "title": "Infrastructure",
    "content": "@TODO",
    "url": "/infrastructure",
    "relUrl": "/infrastructure"
  },
  "12": {
    "id": "12",
    "title": "About",
    "content": " this siteThis documentation site is intended for:  System builders creating a Directory of Services for Hackney &amp;amp; City of London councils.  Developers, adding or improving microservices to the system.It documents:  the components of the system;  how they function together;  how to work with them;  how to deploy them.and more.This documentation site is built with the Jekyll static site generator and uses the Just the Docs theme (documentation).",
    "url": "/about/",
    "relUrl": "/about/"
  },
  "13": {
    "id": "13",
    "title": "Home",
    "content": "Hackney &amp;amp; City Directory of Services DocumentationDocumentation for the system infrastructure.",
    "url": "/",
    "relUrl": "/"
  }
}